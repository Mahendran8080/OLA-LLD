# Main.class – Application Entry Point

> **File**: `Main.class`  
> **Location**: Root of the compiled package (no package declaration in the source).  
> **Purpose**: The compiled `Main` class is the single entry point for the demo/production application.  
> It demonstrates how the domain model (`Driver`, `Rider`, `Location`, `Ride`) and the service layer (`DriverService`, `RiderService`) interact to simulate a ride‑hailing workflow.

---

## 1. Overview

| Layer | Responsibility | Key Classes |
|-------|-----------------|-------------|
| **Domain** | Represents the core business objects. | `models.Driver`, `models.Rider`, `models.Location`, `models.Ride` |
| **Service** | Encapsulates business logic (matching drivers, starting/ending rides). | `services.DriverService`, `services.RiderService` |
| **Application** | Orchestrates a simple scenario: create drivers, request a ride, end it, and query the result. | `Main` |

`Main.class` is a **stand‑alone executable** that can be run with `java Main`. It does not expose any API; it simply prints the flow to `System.out`.

---

## 2. Detailed Breakdown

Below is a reconstruction of the original `Main.java` logic based on the byte‑code constants and method signatures found in the class file.

```java
public class Main {

    public static void main(String[] args) {
        // 1. Create a list of drivers
        List<Driver> drivers = new ArrayList<>();
        drivers.add(new Driver(1, "Driver A", new Location(0.0, 0.0)));
        drivers.add(new Driver(2, "Driver B", new Location(4.0, 0.0)));
        drivers.add(new Driver(3, "Driver C", new Location(1.0, 0.0)));

        // 2. Wire services
        DriverService driverService = new DriverService(drivers);
        RiderService riderService = new RiderService(driverService);

        // 3. Create a rider
        Rider rider = new Rider(1, "Rider One");

        // 4. Request a ride
        System.out.println("--- Rider requests a ride ---");
        Ride ride = riderService.requestRide(
                rider,
                new Location(0.0, 0.0),   // start
                new Location(5.0, 5.0));  // destination

        // 5. End the ride
        System.out.println("--- Ride is ending ---");
        riderService.endRide(rider);

        // 6. Query ride status after ending
        System.out.println("--- Get Ride Info After Ending ---");
        Ride finishedRide = riderService.getRideForRider(rider);
        if (finishedRide != null) {
            System.out.println(finishedRide);
        } else {
            System.out.println("No active ride for Rider One.");
        }
    }
}
```

### Key Points

| Step | What Happens | Relevant Byte‑code |
|------|--------------|--------------------|
| **Driver Creation** | Three `Driver` objects are instantiated with IDs, names, and starting `Location`s. | `models/Driver`, `models/Location` constructors |
| **Service Wiring** | `DriverService` receives the driver list; `RiderService` receives the `DriverService`. | `services/DriverService(List<Driver>)`, `services/RiderService(DriverService)` |
| **Ride Request** | `RiderService.requestRide` is called with a `Rider`, a start `Location`, and a destination `Location`. The method returns a `Ride` object. | `requestRide(Lmodels/Rider;Lmodels/Location;Lmodels/Location;)Lmodels/Ride;` |
| **Ride End** | `RiderService.endRide` removes the active ride from its internal map. | `endRide(Lmodels/Rider;)V` |
| **Ride Query** | `RiderService.getRideForRider` returns the current ride or `null`. | `getRideForRider(Lmodels/Rider;)Lmodels/Ride;` |
| **Output** | Uses `System.out.println` to display status messages and the final ride state. | `java/io/PrintStream.println` |

The class also contains a **string concatenation** helper generated by `StringConcatFactory` for formatting the start/destination coordinates:

```java
String.format("Ride started from: (%f, %f) Destination: (%f, %f)",
              start.getX(), start.getY(), dest.getX(), dest.getY());
```

---

## 3. Integrations

| Component | Interaction | Notes |
|-----------|-------------|-------|
| **`models.Driver`** | Created and stored in a list. | Holds driver ID, name, and current `Location`. |
| **`models.Rider`** | Created once and passed to service methods. | Holds rider ID and name. |
| **`models.Location`** | Used for driver start positions and ride coordinates. | Provides `getX()` and `getY()` methods. |
| **`models.Ride`** | Returned by `requestRide`; stored in `RiderService`'s `activeRides` map. | Contains start/destination locations and driver/rider references. |
| **`services.DriverService`** | Supplies the list of available drivers to `RiderService`. | Likely contains logic to find the nearest driver. |
| **`services.RiderService`** | Orchestrates ride lifecycle: request, end, query. | Maintains a `Map<Rider, Ride>` called `activeRides`. |
| **`java.lang.System`** | Used for console output. | No external dependencies beyond JDK. |

### Flow Summary

1. **DriverService** is initialized with a static driver pool.  
2. **RiderService** uses `DriverService` to match a driver when a ride is requested.  
3. The **Main** class drives the scenario, demonstrating the end‑to‑end flow.  
4. After ending a ride, the service confirms that the ride has been removed from the active map.

---

## 4. Usage

```bash
# Compile (if you have the source)
javac -d bin src/Main.java src/models/*.java src/services/*.java

# Run
java -cp bin Main
```

The console output will resemble:

```
--- Rider requests a ride ---
Ride started from: (0.0, 0.0) Destination: (5.0, 5.0)
--- Ride is ending ---
--- Get Ride Info After Ending ---
No active ride for Rider One.
```

---

## 5. Extending the Demo

- **Add more drivers**: Modify the driver list in `Main`.
- **Persist rides**: Replace the in‑memory `Map` with a database-backed repository.
- **Real‑time updates**: Hook into a messaging system to notify riders when a driver is assigned.

---

### TL;DR

`Main.class` is the **execution driver** for a toy ride‑hailing system. It sets up drivers, requests a ride, ends it, and prints the status, showcasing how the domain models and services collaborate.